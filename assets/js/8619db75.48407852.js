"use strict";(self.webpackChunkjamswiki=self.webpackChunkjamswiki||[]).push([[445],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return u}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=c(t),u=r,h=m["".concat(l,".").concat(u)]||m[u]||d[u]||s;return t?a.createElement(h,i(i({ref:n},p),{},{components:t})):a.createElement(h,i({ref:n},p))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var s=t.length,i=new Array(s);i[0]=m;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var c=2;c<s;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5340:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return d}});var a=t(7462),r=t(3366),s=(t(7294),t(3905)),i=["components"],o={sidebar_position:4},l="MIPS32 Assembler",c={unversionedId:"architecture/mipsAssembler",id:"architecture/mipsAssembler",title:"MIPS32 Assembler",description:"The JAMS's MIPS32 assembles is the advanced assembler that assembles MIPS32 projects.",source:"@site/docs/architecture/mipsAssembler.md",sourceDirName:"architecture",slug:"/architecture/mipsAssembler",permalink:"/docs/architecture/mipsAssembler",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/architecture/mipsAssembler.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"docsSidebar",previous:{title:"Events",permalink:"/docs/architecture/events"},next:{title:"Instructions",permalink:"/docs/architecture/instructions"}},p={},d=[{value:"Procedure",id:"procedure",level:2},{value:"Discovering",id:"discovering",level:3},{value:"Expansion",id:"expansion",level:3},{value:"Address assignation",id:"address-assignation",level:3},{value:"Value assignation",id:"value-assignation",level:3},{value:"Advanced characteristics",id:"advanced-characteristics",level:2},{value:"Relative references",id:"relative-references",level:3},{value:"Nested macros",id:"nested-macros",level:3}],m={toc:d};function u(e){var n=e.components,t=(0,r.Z)(e,i);return(0,s.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"mips32-assembler"},"MIPS32 Assembler"),(0,s.kt)("p",null,"The JAMS's MIPS32 assembles is the advanced assembler that assembles MIPS32 projects."),(0,s.kt)("p",null,"This assembler supports advanced characteristics such as macros, global labels and relative references."),(0,s.kt)("h2",{id:"procedure"},"Procedure"),(0,s.kt)("p",null,"The assembler assembles a project's code in ",(0,s.kt)("strong",{parentName:"p"},"four")," steps: ",(0,s.kt)("strong",{parentName:"p"},"discovering"),", ",(0,s.kt)("strong",{parentName:"p"},"expansion"),", ",(0,s.kt)("strong",{parentName:"p"},"address assignation"),"\nand ",(0,s.kt)("strong",{parentName:"p"},"value assignation"),"."),(0,s.kt)("p",null,"The following snippet will be used to explain the steps:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'    .macro print ( %string )\n    .data\ntext:   .asciiz %string\n    .text \n    la $a0, text\n    li $v0, 4\n    syscall\n    .endmacro\n    \n    .macro printJams ()\n    print ("Welcome to JAMS!\\n")\n    .endmacro\n    \n    .text\n    .globl main print\nmain:   \nlocal:   \n    printJams ()\n')),(0,s.kt)("h3",{id:"discovering"},"Discovering"),(0,s.kt)("p",null,"In this step, the raw text of the project is split into their primitive components, allowing the assembler to understand\nthe composition of each line."),(0,s.kt)("p",null,"At the end of this step, global labels and file labels (labels not defined inside a macro) are registered with no\nassigned value."),(0,s.kt)("p",null,"Macros are also registered here. A macro's identifier is defined by its name and the number of parameters it requires.\nThanks to this, macro overloading is supported. For example, the macro ",(0,s.kt)("inlineCode",{parentName:"p"},"print")," in the previous snippet has the ",(0,s.kt)("inlineCode",{parentName:"p"},"print-1"),"\nidentifier."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Global labels:\nmain - XXXXXXXX\n\nFile labels:\nlocal - XXXXXXXX\n\nGlobal macros:\nprint-1\n\nFile macros:\nprintJams-0\n")),(0,s.kt)("h3",{id:"expansion"},"Expansion"),(0,s.kt)("p",null,"Macro calls are invoked in this step, appending the macro's code at the position of the macro call. This code executes\nthe first assembler step when it is appended. The code is appender right after the macro call, so the macro code will\nalso execute this step."),(0,s.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"Scopes")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"Labels and macros inside a macro have a different scope. If the macro is global, the scope is considered a child of the\nglobal scope. If the macro is local, the scope is a child of the file's scope."),(0,s.kt)("p",{parentName:"div"},"When a scope is the child of another scope, the child can reach its parent's labels and macros. The child can also\ndefine new labels and macros with the same identifier as a parent's label or macro. Even though this behavior is\nallowed, the child will only be able to access the element it defines. This functionality is defined as ",(0,s.kt)("inlineCode",{parentName:"p"},"shadowing"),"."))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'main:   \nlocal:  \n    # Macro printJams-0\n    # Macro print-1\n    .data # Data returns the previous address.\ntext:   .asciiz "Welcome to JAMS!\\n"\n    .text\n    la $s0, text\n    li $v0, 4\n    syscall\n    # Endmacro print-1\n    # Endmacro printJams-0\n')),(0,s.kt)("h3",{id:"address-assignation"},"Address assignation"),(0,s.kt)("p",null,"Once the assembled has expanded the macros, addresses for all instructions, labels and directives are assigned."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'main:   \nlocal:  \n                    # Macro printJams-0\n                    # Macro print-1\n                    \n0x00400000          .data # Data returns the previous address.\n0x10010000      text:    .asciiz "Welcome to JAMS!\\n"\n0x10010010          .text\n\n                    # la is a pseudo-instruction and \n                    # it will be split in two instructions \n0x00400000          la $s0, text\n0x00400008          li $v0, 4\n0x0040000c          syscall\n\n                    # Endmacro print-1\n                    # Endmacro printJams-0\n')),(0,s.kt)("h3",{id:"value-assignation"},"Value assignation"),(0,s.kt)("p",null,"As the final step, the assembler will insert into memory the values the directives and instructions represent."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"                    # Macro printJams-0\n                    # Macro print-1\n                    \n0x10010000          Welcome to JAMS!\\n\\0\n0x00400000          0x3c011001 # la $a0, text\n0x00400004          0x34240000\n0x00400008          0x24020004 # li $v0, 4\n0x0040000c          0x0000000c # syscall\n\n                    # Endmacro print-1\n                    # Endmacro printJams-0\n")),(0,s.kt)("h2",{id:"advanced-characteristics"},"Advanced characteristics"),(0,s.kt)("p",null,"The assembler allows the use of advanced techniques in the development of assembly applications."),(0,s.kt)("h3",{id:"relative-references"},"Relative references"),(0,s.kt)("p",null,"A label can be referenced by an instruction or directive relatively using the special references ",(0,s.kt)("inlineCode",{parentName:"p"},"+")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"-"),"."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"+")," reference references the next label. The ",(0,s.kt)("inlineCode",{parentName:"p"},"-")," reference references the previous label."),(0,s.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"Relative references' scope")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"Relative references can only reference labels ",(0,s.kt)("strong",{parentName:"p"},"on the same scope"),". They cannot reference labels on the parent's scope."))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"main:   \n    li $s0, 0\n    li $s1, 10\nloop:   \n    printJams ()\n    addi $s0, $s0, 1\n    bne $s0, $s1, -\n")),(0,s.kt)("h3",{id:"nested-macros"},"Nested macros"),(0,s.kt)("p",null,"A macro can be defined inside another macro. This is known as a ",(0,s.kt)("strong",{parentName:"p"},"nested macro"),". These macros can only be reached from\nthe parent's scope."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'    .macro printJams ()\n    .macro print (%string)\n    .data\ntext:   .asciiz %string\n    .text\n    la $a0, text\n    li $v0, 4\n    syscall\n    \n    .endmacro\n    print ("Welcome to JAMS!\\n")\n    .endmacro\n')))}u.isMDXComponent=!0}}]);