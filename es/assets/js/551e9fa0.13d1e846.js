"use strict";(self.webpackChunkjamswiki=self.webpackChunkjamswiki||[]).push([[719],{3905:function(e,n,t){t.d(n,{Zo:function(){return l},kt:function(){return m}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o=a.createContext({}),u=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},l=function(e){var n=u(e.components);return a.createElement(o.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=u(t),m=r,b=p["".concat(o,".").concat(m)]||p[m]||d[m]||i;return t?a.createElement(b,s(s({ref:n},l),{},{components:t})):a.createElement(b,s({ref:n},l))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,s=new Array(i);s[0]=p;var c={};for(var o in n)hasOwnProperty.call(n,o)&&(c[o]=n[o]);c.originalType=e,c.mdxType="string"==typeof e?e:r,s[1]=c;for(var u=2;u<i;u++)s[u]=t[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},1982:function(e,n,t){t.r(n),t.d(n,{assets:function(){return l},contentTitle:function(){return o},default:function(){return m},frontMatter:function(){return c},metadata:function(){return u},toc:function(){return d}});var a=t(7462),r=t(3366),i=(t(7294),t(3905)),s=["components"],c={sidebar_position:5},o="Instrucciones",u={unversionedId:"architecture/instructions",id:"architecture/instructions",title:"Instrucciones",description:"Las instrucciones son la parte m\xe1s importante de un lenguaje ensamblador. JAMS permite crear y gestionar instrucciones",source:"@site/i18n/es/docusaurus-plugin-content-docs/current/architecture/instructions.md",sourceDirName:"architecture",slug:"/architecture/instructions",permalink:"/es/docs/architecture/instructions",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/architecture/instructions.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"docsSidebar",previous:{title:"Ensamblador MIPS32",permalink:"/es/docs/architecture/mipsAssembler"},next:{title:"Directivas",permalink:"/es/docs/architecture/directives"}},l={},d=[{value:"Estructura de una instrucci\xf3n.",id:"estructura-de-una-instrucci\xf3n",level:2},{value:"Instrucciones b\xe1sicas",id:"instrucciones-b\xe1sicas",level:3},{value:"Pseudo-instrucciones",id:"pseudo-instrucciones",level:3},{value:"Instrucciones ensambladas",id:"instrucciones-ensambladas",level:2},{value:"Ejecuci\xf3n de una instrucci\xf3n",id:"ejecuci\xf3n-de-una-instrucci\xf3n",level:2},{value:"Conjuntos de instrucciones",id:"conjuntos-de-instrucciones",level:2}],p={toc:d};function m(e){var n=e.components,t=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"instrucciones"},"Instrucciones"),(0,i.kt)("p",null,"Las instrucciones son la parte m\xe1s importante de un lenguaje ensamblador. JAMS permite crear y gestionar instrucciones\nde una manera modular."),(0,i.kt)("h2",{id:"estructura-de-una-instrucci\xf3n"},"Estructura de una instrucci\xf3n."),(0,i.kt)("p",null,"Todas las instrucciones implementan la interfaz ",(0,i.kt)("inlineCode",{parentName:"p"},"Instruction"),". Esta interfaz define conceptos b\xe1sicos de una\ninstrucci\xf3n, como su nombre, su mnem\xf3nico, su documentaci\xf3n o sus par\xe1metros."),(0,i.kt)("p",null,"Esta interfaz tambi\xe9n define los m\xe9todos ",(0,i.kt)("inlineCode",{parentName:"p"},"match"),", usada para comprobar si un mnem\xf3nico y un conjunto de par\xe1metros\nrepresentan una instrucci\xf3n. Estos m\xe9todos son utilizados por el ensamblador para saber qu\xe9 instrucci\xf3n define una\nl\xednea."),(0,i.kt)("p",null,"Por \xfaltimo, la interfaz define el m\xe9todo ",(0,i.kt)("inlineCode",{parentName:"p"},"assemble"),", el cual traduce la instrucci\xf3n en un conjunto de instrucciones\nensambladas. Este m\xe9todo debe ser implementado por las clases hijas."),(0,i.kt)("p",null,"Esta interfaz es implementada por dos clases abstractas b\xe1sicas: ",(0,i.kt)("inlineCode",{parentName:"p"},"BasicInstruction")," y ",(0,i.kt)("inlineCode",{parentName:"p"},"PseudoInstruction"),"."),(0,i.kt)("h3",{id:"instrucciones-b\xe1sicas"},"Instrucciones b\xe1sicas"),(0,i.kt)("p",null,"Las instrucciones b\xe1sicas (representadas por la clase abstracta ",(0,i.kt)("inlineCode",{parentName:"p"},"BasicInstruction"),") representan instrucciones normales\ndel ensamblador. Estas instrucciones tienen una traducci\xf3n directa a c\xf3digo m\xe1quina. Esta clase abstracta define\nelementos m\xe1s concretos, como el c\xf3digo de operaci\xf3n, la unidad aritm\xe9tico-l\xf3gica donde la instrucci\xf3n debe ejecutarse y\nun nuevo m\xe9todo ",(0,i.kt)("inlineCode",{parentName:"p"},"match")," que permite saber si un c\xf3digo de instrucci\xf3n representa la instrucci\xf3n."),(0,i.kt)("p",null,"Esta clase define los m\xe9todos abstractos ",(0,i.kt)("inlineCode",{parentName:"p"},"assembleBasic")," y ",(0,i.kt)("inlineCode",{parentName:"p"},"assembleFromCode"),". Estos m\xe9todos permiten crear un elemento\nde tipo ",(0,i.kt)("inlineCode",{parentName:"p"},"AssembledInstruction")," mediante un c\xf3digo de instrucci\xf3n o un conjunto de par\xe1metros."),(0,i.kt)("p",null,"El m\xe9todo ",(0,i.kt)("inlineCode",{parentName:"p"},"assemble")," de la interfaz ",(0,i.kt)("inlineCode",{parentName:"p"},"Instruction")," est\xe1 implementada por esta clase."),(0,i.kt)("div",{className:"admonition admonition-danger alert alert--danger"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"Constantes globales necesarias")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Todas las instrucciones b\xe1sicas requieren dos constantes globales en su implementaci\xf3n:"),(0,i.kt)("ul",{parentName:"div"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"MNEMONIC"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"String")," que define el mnem\xf3nico de la instrucci\xf3n."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"PARAMETER_TYPES"),": Elemento de tipo ",(0,i.kt)("inlineCode",{parentName:"li"},"InstructionParameterTypes")," que representa los tipos de los par\xe1metros de la\ninstrucci\xf3n.")),(0,i.kt)("pre",{parentName:"div"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class InstructionAbsDouble extends BasicRFPUInstruction<InstructionAbsDouble.Assembled> {\n\n    public static final String MNEMONIC = "abs.d";\n    public static final InstructionParameterTypes PARAMETER_TYPES = new InstructionParameterTypes(\n            ParameterType.EVEN_FLOAT_REGISTER,\n            ParameterType.EVEN_FLOAT_REGISTER\n    );   \n    ...\n}\n')))),(0,i.kt)("h3",{id:"pseudo-instrucciones"},"Pseudo-instrucciones"),(0,i.kt)("p",null,"Las pseudo-instrucciones son instrucciones que el ensamblador convertir\xe1 en un conjunto de instrucciones b\xe1sicas. Pueden\nconsiderarse un conjunto de instrucciones que ejecutan una acci\xf3n com\xfan."),(0,i.kt)("p",null,"Estas instrucciones est\xe1n representadas por la clase ",(0,i.kt)("inlineCode",{parentName:"p"},"PseudoInstruction"),", la cual define el\nm\xe9todo ",(0,i.kt)("inlineCode",{parentName:"p"},"getInstructionAmount"),". Este m\xe9todo le permite saber al ensamblador cu\xe1ntas instrucciones debe esperar que la\npseudo-instrucci\xf3n d\xe9 como resultado dependiendo del conjunto de par\xe1metros dado."),(0,i.kt)("p",null,"Esta clase implementa varios m\xe9todos est\xe1ticos que sirven de utilidad para implementar pseudo-instrucciones r\xe1pidamente."),(0,i.kt)("p",null,"Como ejemplo, la implementaci\xf3n de la pseudo-instrucci\xf3n ",(0,i.kt)("inlineCode",{parentName:"p"},"addi")," ser\xeda la siguiente:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class PseudoInstructionAddi extends PseudoInstruction {\n\n    public static final String MNEMONIC = "addi";\n\n    public static final InstructionParameterTypes PARAMETER_TYPES = new InstructionParameterTypes(\n            ParameterType.REGISTER,\n            ParameterType.REGISTER,\n            ParameterType.SIGNED_16_BIT\n    );\n\n    public PseudoInstructionAddi() {\n        super(MNEMONIC, PARAMETER_TYPES);\n    }\n\n    @Override\n    public int getInstructionAmount(String[] parameters) {\n        return 2;\n    }\n\n    @Override\n    public AssembledInstruction[] assemble(\n            InstructionSet set,\n            int address,\n            ParameterParseResult[] parameters\n    ) {\n        var instructions = instructions(set,\n                InstructionAddiu.class, InstructionAdd.class);\n\n        var addiu = parameters(AT, ZERO, parameters[2]);\n        var add = parameters(parameters[0], AT, parameters[1]);\n\n        return assemble(instructions, addiu, add);\n    }\n}\n')),(0,i.kt)("h2",{id:"instrucciones-ensambladas"},"Instrucciones ensambladas"),(0,i.kt)("p",null,"La clase ",(0,i.kt)("inlineCode",{parentName:"p"},"AssembledInstruction")," representa una instrucci\xf3n ensamblada. Esta clase guarda el entero que representa el\nc\xf3digo de instrucci\xf3n, la instrucci\xf3n que ha creado la instrucci\xf3n ensamblada (puede ser una instrucci\xf3n b\xe1sica o una\npseudo-instrucci\xf3n), y la instrucci\xf3n b\xe1sica que representa."),(0,i.kt)("p",null,"Este tipo de elementos sirve \xfanicamente para guardar la informaci\xf3n sobre la instrucci\xf3n. Las clases hijas\nde ",(0,i.kt)("inlineCode",{parentName:"p"},"AssembledInstruction")," pueden definir m\xe9todos \xfatiles que permiten sacar par\xe1metros del c\xf3digo de instrucci\xf3n."),(0,i.kt)("h2",{id:"ejecuci\xf3n-de-una-instrucci\xf3n"},"Ejecuci\xf3n de una instrucci\xf3n"),(0,i.kt)("p",null,"Por \xfaltimo, las instrucciones tambi\xe9n est\xe1n definidas por una clase ",(0,i.kt)("inlineCode",{parentName:"p"},"InstructionExecution"),". Esta clase implementa la\nejecuci\xf3n de una instrucci\xf3n en una arquitectura, e implementa muchos m\xe9todos \xfatiles que los hijos pueden usar para\ndefinir la ejecuci\xf3n de sus instrucciones."),(0,i.kt)("p",null,"La clase ",(0,i.kt)("inlineCode",{parentName:"p"},"InstructionExecution")," no debe ser extendida directamente, sino que se debe extender la\nclase ",(0,i.kt)("inlineCode",{parentName:"p"},"SingleCycleExecution")," para ejecuciones uni-ciclo y ",(0,i.kt)("inlineCode",{parentName:"p"},"MultiCycleExecution")," para ejecuciones multi-ciclo o\nsegmentadas."),(0,i.kt)("p",null,"Estas ejecuciones deben ser registradas en la instrucci\xf3n usando el m\xe9todo ",(0,i.kt)("inlineCode",{parentName:"p"},"addExecutionBuilder"),"."),(0,i.kt)("h2",{id:"conjuntos-de-instrucciones"},"Conjuntos de instrucciones"),(0,i.kt)("p",null,"Las instrucciones est\xe1n agrupadas en ",(0,i.kt)("strong",{parentName:"p"},"conjuntos de instrucciones"),". Un proyecto usar\xe1 un conjunto de instrucciones para\nensamblar su c\xf3digo, ayudar al usuario en el editor e interpretar el c\xf3digo m\xe1quina del simulador. Los conjuntos de\ninstrucciones est\xe1n gestionados por el gestor ",(0,i.kt)("inlineCode",{parentName:"p"},"InstructionSetManager"),"."))}m.isMDXComponent=!0}}]);